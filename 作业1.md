T1：

思路：想要实现两个数组中位数的查找，最简单的思路就是把两个数组合并后排序并查找中位数，或者每次查找最小的数（k=1），然后比较大小，但前者的复杂度取决于排序算法，后者的复杂度也是多项式复杂度，都不满足。

本题目要求对数时间复杂度，并且可以查询每个数据库中第k小的数，立刻想到只能通过二分查找，每次缩小log（n）的查找范围才有可能实现。

程序（伪代码）：

//初始化 k 为 n - 1

//初始化两个指针 index1 和 index2 为 0

k = n - 1

index1, index2 = 0, 0

while(k > 0)

`    `#计算新指针：

`    `new\_index1 = min(index1 + k // 2, n - 1)

`    `new\_index2 = min(index2 + k // 2, n - 1)

`    `#这里假设数组已经排序好了来代替查询第k小的函数

`    `pivot1, pivot2 = database1[new\_index1], database2[new\_index2]

`    `if pivot1 <= pivot2:

`        `#减去被淘汰的数据数量：

`        `k -= new\_index1 - index1 + 1

`        `#更新 index1：

`        `index1 = new\_index1 + 1

`    `else:

`        `#减去被淘汰的数据数量

`        `k -= new\_index2 - index2 + 1

`        `#更新 index2

`        `index2 = new\_index2 + 1

print(min(database1[index1], database2[index2]))

证明：设两个数据库的大小都为n，一共有2n个数据，在里面查找中位数（题目中好像定义中位数为排序第n小的数）。我们可以比较每个数据库中排序第[n/2]的数，加入数据库A的中位数大于等于B的中位数，那么可以知道，不仅B中较大的n/2个数大于B的中位数，A中较大的n/2个数也大于B的中位数，比B的中位数大的数已经达到了n个，因此B中较小的n/2个数一定不是中位数的候选了，直接筛选掉，反之筛选掉A中较小的n/2个数。此时一个数据库的长度变为n/2，另一个的长度还是n，继续刚才的步骤，虽然此时已经不等长了但依然奏效。当被筛选掉的数达到n-1时，比较两个数据库中最小的数，较小的就是第n个数了。

T2

（1）蛮力算法的建模思路很简单，就是依次握手，把所有的配对情况遍历下来，用一个数据记录最小值，每当出现更小距离时更新，最后得到的就是最小值。握手的次数为O(n²)，因此时间复杂度为O(n²)。伪代码如下：

min\_distance = 正无穷

num = len(points)

for i in range(num):

`    `for j in range(i+1,num):

`        `if distance(i,j) < min\_distance:

`            `min\_distance = distance(i,j)

return min\_distance

（2）利用分治算法优化

根据x坐标对这10个点进行排序，创建一个按x排序的点列表，沿着通过中位x坐标的垂直线，将点集划分为两个大致相等的部分，递归地在每一半中找到最近的点对。令d为两个递归调用得到的最小距离。

创建一个距离中位线水平距离小于d的点条带。根据y坐标对点条带进行排序。对于条带中的每个点p，两两计算点之间的距离。如果其中任何一对距离小于d，则使用较小的距离更新d，最终的d值将是最近点对之间的距离。

伪代码：

def findClosestPair(points):

`    `#如果点集中的点数小于等于3个，使用蛮力算法计算最近点对的距离

`    `if len(points) <= 3:

`        `return bruteForceClosestPair(points)

`    `# 按x坐标对点集进行排序，利用快排或归并排序

`    `points.sort(key=lambda point: point.x)

`    `# 将点集分成左右两半

`    `mid = len(points) // 2

`    `left\_half = points[:mid]

`    `right\_half = points[mid:]

`    `# 递归地找到左右两半的最近点对的距离

`    `left\_distance = findClosestPair(left\_half)

`    `right\_distance = findClosestPair(right\_half)

`    `# 取左右两半最近点对距离的较小值

`    `min\_distance = min(left\_distance, right\_distance)

`    `# 创建一个在中间区域内的点条带

`    `strip = []

`    `mid\_x = (left\_half[-1].x + right\_half[0].x) / 2.0



`    `for point in points:

`        `if abs(point.x - mid\_x) < min\_distance:

`            `strip.append(point)

`    `# 在点条带中查找更小的距离

`    `strip\_distance = bruteForceClosestPair(strip)

`    `# 返回左右两半和点条带中的最小距离

`    `return min(min\_distance, strip\_distance)

\# 蛮力算法函数

def bruteForceClosestPair(points):

`    `min\_distance = float('inf')

`    `n = len(points)



`    `for i in range(n):

`        `for j in range(i+1, n):

`            `distance = distance(i,j)

`            `min\_distance = min(min\_distance, distance)

`    `return min\_distance

时间复杂度：初始对点进行排序需要O(nlog(n))的时间（快速排序或归并排序），递归的划分和求解每一半的最小距离需要O(n)的时间，计算条带中点直接的距离为O(1)，总体的时间复杂度为O(nlog(n))

**正确性和完备性证明**：

**正确性证明**：

**基本情况的正确性**：首先，我们证明算法在基本情况下的正确性。当点集中只包含2个或3个点时，我们可以使用蛮力算法来计算最近点对的距离。蛮力算法遍历所有可能的点对，因此它能够确保找到最近的点对。这个步骤的正确性是显然的。

**分治策略的正确性**：算法的核心在于分治策略。我们首先将点集按x坐标排序，然后将点集分成左右两半。我们递归地在左半部分和右半部分找到最近点对的距离，然后取两者中的较小值为最终结果。

假设左半部分找到的最近点对距离为D1，右半部分找到的最近点对距离为D2。根据分治策略，我们取D1和D2中的较小值作为候选的最近点对距离。

接下来，我们考虑点集中可能跨越左右两半部分的最近点对。这些点必然位于中间区域内，即点条带。我们创建一个点条带，并在其中查找可能的最近点对距离。这个点条带内的最近点对距离称为D3。

最后，我们取D1、D2和D3中的最小值作为最终的最近点对距离。这样，我们考虑了左半部分、右半部分和点条带内的所有情况，确保了最近点对不会被漏掉。

**完备性证明**：

**基本情况的完备性**：在算法的基本情况下，我们使用蛮力算法来查找最近点对，而蛮力算法会考虑所有可能的点对。因此，基本情况下算法是完备的。

**分治策略的完备性**：算法的分治策略确保了点集被分成左右两半，并递归地考虑了左半部分和右半部分的情况。然后，它通过查找点条带内的可能点对来考虑可能跨越左右两半的情况。这个步骤涵盖了所有可能的点对，因此是完备的。

T3 

思路：

朴素的算法计算3n，就是累乘得到，复杂度为O(n)

而在这个题中，每次×3需要一次运算，×9也需要一次运算，但后者和前者相比，一次就处理了两次×3，那有没有一种办法可以让我们重复利用这部分幂呢？有一种平时我们也经常使用的办法。在口算28时，我们通常先把28转化为44，再转化为162，最后得到256。

因此这里有一种分治的思路，可以把计算过程不断拆分。首先把指数转化为二进制数，我们发现，（31）2 = 310，（310）2 = 3100   …我们可以把31111转化为31000 × 3100 × 310 × 31，前者由后者的平方得到，最后相乘，原来是3的15次方，这样只用到了6次运算。当n足够大时，复杂度可以降低到O(logn)

伪代码：

朴素的方法非常简单，直接乘就可以

def naive\_power\_of\_three(base,n):

`    `result = 1

`    `for i in range(n):

`        `result \*= base

`    `return result

在时间优化的代码实现上，有一种更加省空间的做法，不用将31 310 3100…都算出来后统一相加，而是可以边乘边加，也省去了转化二进制的过程。

def calculate\_power(base,n):

`    `result = 1

`    `while n > 0:

`        `if n % 2 == 1:

`            `result \*= base

`        `base \*= base

`        `n //= 2

`    `return result

证明：n为偶数时，n/2，并将底数平方，比如将28转化为44

N为奇数时，同样n/2，并将底数平方，但这里要把指数因整除损失的1补进result里。

当n减小到1时，result再乘一次base，n变为0，循环结束。


T4

思路与证明：要实现二叉树的翻转，递归算法即可实现，时间复杂度也满足O(n)的要求。当递归到叶子节点的时候就会return，每个节点都会作为函数的输入，因此一共调用n次函数，每次函数的复杂度为O(1)，总复杂度O(n)

伪代码：

def invertBinaryTree(root):

`    `if root is None:

`        `return



`    `invertBinaryTree(root.left)

`    `invertBinaryTree(root.right)



`    `root.left, root.right = root.right, root.left





T5

思路与证明：根据题意，应该是有n个房间排在一起，每个房间里住一个囚犯，每个囚犯有一种宗教，这个宗教是m种宗教之一，当相邻的两个房间的囚犯如果宗教相同就会发生越狱。在m和n较小时可以数出来，但当数量较大时，可能性就有nm种可能，在这些可能中数出所有结果复杂度会很高。

利用分治的思路和组合数学中给花坛上色的模型，可以简历递推关系。假设对于n个房间，m种宗教，发生越狱的可能有T(n)种，现在假定第一间房间的宗教为随意一种，第二间房间的宗教如果和第一间房间相同，越狱已经发生，剩下n-2间房间的宗教可以任意，有(n-2)m种可能；如果第二间和第一间房间不同，那么可以保证第一间房间的囚犯不会越狱，考虑剩下n-1间房间，有T(n-1)种可能。至此，递推关系已经建立成功。

将所有的可能分为两种：前两间房间宗教相同或不同。相同的情况下，有mn-1种；不同的情况下，有(m-1)T(n-1)种。递推公式：T(n) = (m-1)T(n-1) + mn-1

初始条件：只有一个人时，不会发生越狱

伪代码：

def escape(n, m):

`    `if n == 1:

`        `return 0 

`    `return (m - 1) \* escape(n - 1, m) + m \*\* (n-1)
